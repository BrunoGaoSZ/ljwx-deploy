apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-provision-script
  namespace: infra
  labels:
    app: postgres
    component: provisioning
    managed-by: gitops
data:
  create-db-user.sh: |
    #!/bin/bash
    set -e

    # ============================================
    # PostgreSQL Database Provisioning Script
    # ============================================
    # This script creates:
    # 1. Database: {project}_{env}
    # 2. User: {project}_{env}_user
    # 3. Grants minimal required permissions
    # 4. Creates Kubernetes Secret in target namespace
    #
    # Idempotent: Safe to run multiple times
    # ============================================

    # Colors for output
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    RED='\033[0;31m'
    NC='\033[0m' # No Color

    log_info() {
        echo -e "${GREEN}[INFO]${NC} $1"
    }

    log_warn() {
        echo -e "${YELLOW}[WARN]${NC} $1"
    }

    log_error() {
        echo -e "${RED}[ERROR]${NC} $1"
    }

    # ============================================
    # Validate Input Parameters
    # ============================================

    if [ -z "$PROJECT_NAME" ]; then
        log_error "PROJECT_NAME is required"
        exit 1
    fi

    if [ -z "$ENV" ]; then
        log_error "ENV is required (dev/staging/prod)"
        exit 1
    fi

    if [ -z "$TARGET_NAMESPACE" ]; then
        log_error "TARGET_NAMESPACE is required"
        exit 1
    fi

    # Validate environment
    if [[ ! "$ENV" =~ ^(dev|staging|prod)$ ]]; then
        log_error "ENV must be one of: dev, staging, prod"
        exit 1
    fi

    # Sanitize project name (lowercase, replace hyphens with underscores)
    PROJECT_NAME=$(echo "$PROJECT_NAME" | tr '[:upper:]' '[:lower:]' | tr '-' '_')

    # ============================================
    # Generate Names
    # ============================================

    DB_NAME="${PROJECT_NAME}_${ENV}"
    DB_USER="${PROJECT_NAME}_${ENV}_user"
    # Secret name must use hyphens (Kubernetes doesn't allow underscores)
    SECRET_NAME="postgres-$(echo $PROJECT_NAME | tr '_' '-')-${ENV}"

    log_info "============================================"
    log_info "Database Provisioning"
    log_info "============================================"
    log_info "Project: $PROJECT_NAME"
    log_info "Environment: $ENV"
    log_info "Database: $DB_NAME"
    log_info "User: $DB_USER"
    log_info "Secret: $SECRET_NAME (in namespace: $TARGET_NAMESPACE)"
    log_info "============================================"

    # ============================================
    # Generate Secure Password
    # ============================================

    if [ -z "$DB_PASSWORD" ]; then
        log_info "Generating secure password..."
        DB_PASSWORD=$(head /dev/urandom | tr -dc 'A-Za-z0-9!@#$%^&*' | head -c 20)
        log_info "Password generated (20 characters)"
    else
        log_info "Using provided password"
    fi

    # ============================================
    # Connect to PostgreSQL
    # ============================================

    export PGHOST="${PGHOST:-postgres-lb.infra.svc.cluster.local}"
    export PGPORT="${PGPORT:-5432}"
    export PGUSER="${PGUSER:-postgres}"
    # PGPASSWORD should be set via Secret

    log_info "Connecting to PostgreSQL at $PGHOST:$PGPORT"

    # Test connection
    if ! psql -c "SELECT version();" > /dev/null 2>&1; then
        log_error "Failed to connect to PostgreSQL"
        exit 1
    fi

    log_info "✓ Connected to PostgreSQL"

    # ============================================
    # Create Database (Idempotent)
    # ============================================

    log_info "Creating database '$DB_NAME'..."

    if psql -lqt | cut -d \| -f 1 | grep -qw "$DB_NAME"; then
        log_warn "Database '$DB_NAME' already exists, skipping creation"
    else
        psql -c "CREATE DATABASE $DB_NAME;"
        log_info "✓ Database '$DB_NAME' created"
    fi

    # ============================================
    # Create User (Idempotent)
    # ============================================

    log_info "Creating user '$DB_USER'..."

    if psql -tAc "SELECT 1 FROM pg_roles WHERE rolname='$DB_USER'" | grep -q 1; then
        log_warn "User '$DB_USER' already exists"

        # Update password
        psql -c "ALTER USER $DB_USER WITH PASSWORD '$DB_PASSWORD';"
        log_info "✓ Password updated for user '$DB_USER'"
    else
        psql -c "CREATE USER $DB_USER WITH PASSWORD '$DB_PASSWORD';"
        log_info "✓ User '$DB_USER' created"
    fi

    # ============================================
    # Revoke Public Permissions
    # ============================================

    log_info "Revoking public permissions on database '$DB_NAME'..."
    psql -c "REVOKE ALL ON DATABASE $DB_NAME FROM PUBLIC;"
    log_info "✓ Public permissions revoked"

    # ============================================
    # Grant Minimal Permissions
    # ============================================

    log_info "Granting permissions to user '$DB_USER'..."

    # Grant CONNECT
    psql -c "GRANT CONNECT ON DATABASE $DB_NAME TO $DB_USER;"
    log_info "✓ CONNECT permission granted"

    # Connect to the target database
    export PGDATABASE="$DB_NAME"

    # Grant Schema permissions
    psql -c "GRANT USAGE, CREATE ON SCHEMA public TO $DB_USER;"
    log_info "✓ Schema permissions granted"

    # Grant table permissions (for future tables)
    psql -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO $DB_USER;"
    log_info "✓ Table permissions granted"

    # Grant sequence permissions
    psql -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT, UPDATE ON SEQUENCES TO $DB_USER;"
    log_info "✓ Sequence permissions granted"

    # Grant function permissions
    psql -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT EXECUTE ON FUNCTIONS TO $DB_USER;"
    log_info "✓ Function permissions granted"

    # ============================================
    # Verify Permissions
    # ============================================

    log_info "Verifying permissions..."

    # Check if user can connect
    if PGPASSWORD="$DB_PASSWORD" psql -U "$DB_USER" -d "$DB_NAME" -c "SELECT current_database(), current_user;" > /dev/null 2>&1; then
        log_info "✓ User can connect and query"
    else
        log_error "User cannot connect or query"
        exit 1
    fi

    # ============================================
    # Create Kubernetes Secret
    # ============================================

    log_info "Creating Kubernetes Secret '$SECRET_NAME' in namespace '$TARGET_NAMESPACE'..."

    # Check if namespace exists
    if ! kubectl get namespace "$TARGET_NAMESPACE" > /dev/null 2>&1; then
        log_error "Namespace '$TARGET_NAMESPACE' does not exist"
        log_info "Creating namespace '$TARGET_NAMESPACE'..."
        kubectl create namespace "$TARGET_NAMESPACE"
    fi

    # Construct DATABASE_URL
    DATABASE_URL="postgresql://${DB_USER}:${DB_PASSWORD}@${PGHOST}:${PGPORT}/${DB_NAME}"

    # Create or update Secret
    kubectl create secret generic "$SECRET_NAME" \
        --namespace="$TARGET_NAMESPACE" \
        --from-literal=POSTGRES_HOST="$PGHOST" \
        --from-literal=POSTGRES_PORT="$PGPORT" \
        --from-literal=POSTGRES_DB="$DB_NAME" \
        --from-literal=POSTGRES_USER="$DB_USER" \
        --from-literal=POSTGRES_PASSWORD="$DB_PASSWORD" \
        --from-literal=DATABASE_URL="$DATABASE_URL" \
        --dry-run=client -o yaml | kubectl apply -f -

    # Add labels
    kubectl label secret "$SECRET_NAME" \
        -n "$TARGET_NAMESPACE" \
        app="$PROJECT_NAME" \
        env="$ENV" \
        db-provider=infra-postgres \
        --overwrite

    log_info "✓ Secret '$SECRET_NAME' created/updated in namespace '$TARGET_NAMESPACE'"

    # ============================================
    # Summary
    # ============================================

    log_info "============================================"
    log_info "✓ Provisioning Completed Successfully"
    log_info "============================================"
    log_info "Database: $DB_NAME"
    log_info "User: $DB_USER"
    log_info "Secret: $SECRET_NAME (namespace: $TARGET_NAMESPACE)"
    log_info ""
    log_info "Connection Info:"
    log_info "  Host: $PGHOST"
    log_info "  Port: $PGPORT"
    log_info "  Database: $DB_NAME"
    log_info "  User: $DB_USER"
    log_info ""
    log_info "To use in your application:"
    log_info "  kubectl get secret $SECRET_NAME -n $TARGET_NAMESPACE -o yaml"
    log_info "============================================"
